package mqclient

//Parse fastjson encoding
//Reference: https://github.com/zjykzk/rocketmq-client-go/tree/master/fastjson

import (
	"errors"
	"unicode"
)

// ParseArray parses the data generated by the fastJson library, and returns array of byte array
func ParseArray(d []byte) ([][]byte, error) {
	var r [][]byte
	for i, l := firstNotSpace(d)+1, len(d); i < l; {
		var (
			o   []byte
			k   int
			err error
		)
		switch n := d[i]; n {
		case '{':
			o, k, err = readObject(d[i:])
		case '[':
			o, k, err = readArray(d[i:])
		case '"':
			o, k, err = readString(d[i:])
		case '-', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9':
			o, k, err = readNumber(d[i:])
		case 't', 'f':
			o, k, err = readBool(d[i:])
		case 'n':
			o, k, err = readNull(d[i:])
		case ',':
			i++
			continue
		case ']':
			return r, nil
		default:
			if unicode.IsSpace(rune(n)) {
				i++
				continue
			}

			return nil, errors.New(
				"[BUG] cannot parse ARRAY data:\"" + string(d) + "\", char:'" + string(n) + "'",
			)
		}

		if err != nil {
			return nil, err
		}
		r = append(r, o)
		i += k
	}

	return nil, errors.New("[BUG] cannot parse ARRAY \"" + string(d) + "\"")
}

// ParseObject parses the data generated by the fastJson library, and returns one map whose
// key is the key field name, value is sub-byte array
func ParseObject(d []byte) (map[string][]byte, error) {
	m := map[string][]byte{}

	var k string
	for i, l := firstNotSpace(d), len(d); i < l; {
		switch n := d[i]; n {
		case '{', ',', ':':
			i++

			s, j, err := readKV(d[i:])
			if err != nil {
				return nil, err
			}
			i += j

			if n == ':' {
				m[k] = s
			} else {
				k = string(s)
			}
		case 'n':
			_, _, err := readNull(d[i:])
			if err != nil {
				return nil, err
			}
			return nil, nil
		case '}':
			return m, nil
		default:
			return nil, errors.New(
				"[BUG] cannot parse OBJECT \"" + string(d) + "\", char:'" + string(n) + "'",
			)
		}
	}
	return nil, errors.New("[BUG] cannot parse OBJECT \"" + string(d) + "\"")
}

func readObject(d []byte) ([]byte, int, error) {
	for i, l := 0, len(d); i < l; {
		switch n := d[i]; {
		case n == '{' || n == ',' || n == ':':
			i++
			_, k, err := readKV(d[i:])
			if err != nil {
				return nil, 0, err
			}
			i += k
		case n == '}':
			return d[:i+1], i + 1, nil
		default:
			return nil, 0, errors.New(
				"[BUG] cannot read OBJECT \"" + string(d) + "\", char:'" + string(n) + "'",
			)
		}
	}

	return nil, 0, errors.New("[BUG] cannot read OBJECT \"" + string(d) + "\"")
}

func readKV(d []byte) ([]byte, int, error) {
	var (
		o   []byte
		k   int
		err error
	)

	for i, l := 0, len(d); i < l; i += k {
		switch n := d[i]; n {
		case '{':
			o, k, err = readObject(d[i:])
		case '[':
			o, k, err = readArray(d[i:])
		case '"':
			o, k, err = readString(d[i:])
		case '-', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9':
			o, k, err = readNumber(d[i:])
		case 't', 'f':
			o, k, err = readBool(d[i:])
		case 'n':
			o, k, err = readNull(d[i:])
		case ':', '}', ',':
			return o, i, nil
		default:
			if unicode.IsSpace(rune(n)) {
				k = 1
				continue
			}
			return nil, 0, errors.New(
				"[BUG] canot readKV \"" + string(d) + "\", char:'" + string(n) + "'",
			)
		}

		if err != nil {
			return nil, 0, err
		}
	}
	return nil, 0, errors.New("[BUG] canot readKV \"" + string(d) + "\"")
}

func readString(d []byte) ([]byte, int, error) {
	s, e, l := -1, -1, len(d)

	for i := 0; i < l; i++ {
		if d[i] == '"' {
			s = i
			break
		}
	}

	for i := s + 1; i < l; i++ {
		if d[i] == '"' {
			if i > 0 && d[i-1] == '\\' {
				continue
			}
			e = i
			break
		}
	}

	if s == -1 || e == -1 {
		return nil, e, errors.New("[BUG] cannot process string:" + string(d))
	}

	return d[s+1 : e], e + 1, nil
}

func readNumber(d []byte) ([]byte, int, error) {
	for i, n := range d {
		switch {
		case n >= '0' && n <= '9':
		case n == '-' || n == '+':
		case n == 'e' || n == 'E':
		case n == '.':
		default:
			if i == 0 {
				return nil, 0, errors.New(
					"[BUG] cannot process NUMBER \"" + string(d) + "\", unknow char:'" + string(n) + "'",
				)
			}

			return d[0:i], i, nil
		}
	}

	return d, len(d), nil
}

func readArray(d []byte) ([]byte, int, error) {
	var (
		k   int
		err error
	)

	for i, l := 0, len(d); i < l; i += k {
		switch n := d[i]; {
		case n == '[' || n == ',' || unicode.IsSpace(rune(n)):
			k = 1
			continue
		case n == ']':
			return d[:i+1], i + 1, nil
		case (n >= '0' && n <= '9') || n == '-':
			_, k, err = readNumber(d[i:])
		case n == '"':
			_, k, err = readString(d[i:])
		case n == '{':
			_, k, err = readObject(d[i:])
		case n == 't' || n == 'f':
			_, k, err = readBool(d[i:])
		case n == 'n':
			_, k, err = readNull(d[i:])
		default:
			return nil, 0, errors.New(
				"[BUG] cannot process ARRAY:\"" + string(d) + "\", unknow char:'" + string(n) + "'",
			)
		}

		if err != nil {
			return nil, 0, err
		}
	}

	return nil, 0, errors.New("[BUG] cannot process ARRAY:\"" + string(d) + "\"")
}

func firstNotSpace(d []byte) int {
	s := 0
	for l := len(d); s < l && unicode.IsSpace(rune(d[s])); s++ {
	}
	return s
}

func readBool(d []byte) ([]byte, int, error) {
	b := d[0]

	if b == 't' {
		return readValue(d, "true")
	}

	if b == 'f' {
		return readValue(d, "false")
	}

	return nil, 0, errors.New("[BUG] cannot parse BOOL:\"" + string(d) + "\"")
}

func readNull(d []byte) ([]byte, int, error) {
	return readValue(d, "null")
}

func readValue(d []byte, v string) ([]byte, int, error) {
	l := len(v)
	if len(d) < l {
		return nil, 0, errors.New("[BUG] cannot parse " + v + ":\"" + string(d) + "\"")
	}

	if string(d[:l]) != v {
		return nil, 0, errors.New("[BUG] cannot parse " + v + ":\"" + string(d) + "\", bad value")
	}

	return d[:l], l, nil
}
